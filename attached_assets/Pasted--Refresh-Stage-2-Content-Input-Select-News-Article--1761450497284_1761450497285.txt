вижу баг: после Refresh в Stage 2 («Content Input / Select News Article») с карточек новостей исчезают красные бейджи со score. Ниже — короткое ТЗ для реплита, чтобы это починить и больше не воспроизводилось.

ТЗ: стабильный показ и сохранение score на карточках статей

Контекст/симптом
	•	Экран: Stage 2 → Select News Article.
	•	До рефреша карточки показывают красный бейдж со «score» (пример: 45).
	•	После нажатия Refresh или перезагрузки страницы бейджи пропадают у всех карточек.
	•	Скриншоты до/после у заказчика есть.

Цель
	•	Score должен отображаться всегда: при первом рендере, после Refresh, при пагинации («Show More Older Articles»), при фильтрах и после «Parse Extended».
	•	Score должен быть единым полем (score: number 0–100) в API-ответах для всех списков («Recent», «Old», пагинация).
	•	Если score ещё не посчитан — показываем placeholder и автоматически дотягиваем/досчитываем, не теряя бейдж после обновлений.

⸻

Требования к backend
	1.	Нормализация DTO
	•	В ответах списка статей вернуть единое поле:

type ArticleDTO = {
  id: string
  title: string
  source: string
  publishedAt: string
  summary?: string
  // единое поле:
  score?: number // 0–100
  scoreBreakdown?: { hook?: number; novelty?: number; trend?: number } // опционально
}


	•	Если в БД сейчас aiScore, relevanceScore, priority и т.п. — маппить их в score (приоритет: aiScore → relevanceScore → priority).

	2.	Единый флаг во всех эндпоинтах списка
	•	Эндпоинты «Recent»/«Old»/пагинация обязаны принимать флаг withScores=true и всегда возвращать score при наличии.
	•	Если withScores не передан — дефолт = true. (Иначе фронт при любом рефакторе опять потеряет счёт.)
	3.	Кэш и фоновые досчёты
	•	Кэшировать результат скоринга (TTL 30–60 мин) по ключу источника/URL.
	•	Для свежих статей, у которых нет score, поставить фоновой job на расчёт (queue), а в ответе вернуть score: null.
	•	Добавить эндпоинт GET /api/news/score/:id (или включить long-poll в списке), который возвращает актуальный score для карточки.
	4.	Совместимость со «Parse Extended»
	•	Если после «Parse Extended» данные статьи обновились, не обнулять уже посчитанный score; пересчитывать только если изменилось существенное содержимое.
	5.	Логи и метрики
	•	Логировать долю карточек без score в выдаче + причину (нет в БД / job в очереди / ошибка).
	•	Возвращать структурированную ошибку при сбоях скоринга (5xx/429), с retry хедерами.

⸻

Требования к frontend
	1.	Отображение бейджа
	•	Компонент карточки берёт score как:

const score =
  article.score ??
  article.aiScore ??
  article.relevanceScore ??
  null;


	•	Состояния:
	•	number → показать красный бейдж c числом.
	•	null | undefined → показать серый бейдж-скелетон и запустить ленивый догруз GET /news/score/:id (или ждать инвалидацию списка).
	•	Ошибка загрузки → серый бейдж с «—» и tooltip «Score недоступен. Нажмите Refresh для повторной попытки».

	2.	Единые query keys и флаги
	•	Все запросы списка статей должны слать withScores=true.
	•	Ключи React Query нормализовать (например, ['news', { range, page, filters, withScores: true }]), чтобы Refresh не приводил к переключению на другой набор данных без score.
	•	При Refresh делать invalidateQueries по ключу списка, а не новый «голый» фетч.
	3.	Пагинация и «Show more older»
	•	При дозагрузке следующих страниц не терять уже загруженные карточки со score (merge-append).
	•	Для новых карточек сразу показывать скелетон бейджа и догружать score.
	4.	UX защиты
	•	Если список содержит >20% карточек без score, выводить unobtrusive banner: «Выполняется анализ релевантности — оценки появятся автоматически».
	•	Tooltip на бейдже: число +, если есть, краткий breakdown.

⸻

Диагностика/гипотеза причины (почему пропал сейчас)
	•	После нажатия Refresh фронт уходит на эндпоинт без флага withScores или на другой роут («Recent»), где backend не добавляет поле score (или имя поля отличается: relevanceScore).
	•	Вторая вероятность — новый набор (Recent) не успел пройти скоринг; фронт не показывает placeholder и не делает догрузку, поэтому кажется, будто «скор исчез».
	•	Есть шанс расхождения названий полей между «Recent» и «Old» ручками (например, один возвращает score, другой aiScore).

⸻

Acceptance Criteria
	1.	На Stage 2, в разделах Recent и Old, до и после Refresh/перезагрузки у всех карточек, где score есть в БД, виден красный бейдж с числом.
	2.	Для свежих карточек без посчитанного score отображается серый бейдж-скелетон; через ≤60 сек бейдж автоматически заполняется числом, без ручного Refresh.
	3.	Пагинация «Show More Older Articles» не убирает бейджи с ранее загруженных карточек; новые карточки получают бейдж/скелетон по правилу выше.
	4.	Никаких различий в поле (всегда score) и в структуре DTO между «Recent» и «Old».
	5.	Тест: быстро 3× подряд нажать Refresh — бейджи остаются стабильны, ошибок в консоли нет.

⸻

Быстрый хотфикс (если нужно прямо сейчас)
	•	На фронте: в запрос «Refresh» принудительно добавьте withScores=true и в маппинге данных используйте фолбэки aiScore/relevanceScore.
	•	Поставьте скелетон-бейдж и ленивую догрузку score по id.
	•	На бэке: убедиться, что обе ручки (Recent/Old) прокидывают score одинаково; если нет — временно проставлять score = aiScore ?? relevanceScore ?? null.

Если нужно — набросаю diff-патчи под ваши файлы (routes.ts, news-service.ts, компонент карточки) — скажи, укажу точные пути/функции.