Окей, спокойно разложу по полочкам что сейчас ломается и как это починить без развала нашего флоу «кандидат → сравнить → принять → озвучка».

⸻

1) «Сначала закончите анализ» при переходе к озвучке

Что происходит

Сейчас кнопка «Перейти к озвучке» заблокирована условием вида:

// где-то в Stage 3/5
if (!currentVersion.metrics) { showToast("Сначала закончите анализ") }

Из-за рефакторинга «кандидат→принять» у нас две валидные ситуации:
	•	Анализ ещё идёт для кандидата vN+1, но пользователь хочет идти дальше (это ок – анализ влияет на рекомендации, а не на саму озвучку).
	•	Анализ готов у кандидата, но UI смотрит на текущую vN, у которой metrics=null → ложная блокировка.

Как исправить (не ломая идею)
	•	Привяжем проверку к той версии, которую сейчас редактируем/видим:
	•	если есть кандидат → проверять candidate.metrics
	•	иначе → current.metrics
	•	Разрешить переход даже без метрик, но с предупреждением и CTA:
	•	тост/диалог: «Анализ ещё не завершён. Можно продолжить озвучку сейчас или дождаться результатов».
Кнопки: «Продолжить без анализа» / «Подождать»
	•	Для «строгого» режима (если очень нужно): блокировать только когда идёт критическая операция (например, авто-применение рекомендаций), а не просто анализ.

Практика (минимальный патч)

const activeVersion = candidate ?? current; // единая точка истины

const canProceed = true; // не блокируем жестко
const warnAnalysisPending = !activeVersion.metrics;

onClickProceed = () => {
  if (warnAnalysisPending) {
    toast({
      title: "Анализ ещё в процессе",
      description: "Можно продолжить озвучку сейчас, анализ завершится в фоне.",
      action: <Button onClick={goToStage4}>Продолжить</Button>
    });
  } else {
    goToStage4();
  }
}


⸻

2) «Старый дизайн справа» и рекомендации «не к той версии»

Что происходит

Мы уже научили редактор показывать кандидата, если он есть. Но правая панель («Инструменты», рекомендации) всё ещё фетчит по currentVersionId, а не по activeVersionId. В итоге:
	•	Слева: сцены кандидата v5
	•	Справа: рекомендации для текущей v4 (устаревшие) → ощущение «старого дизайна» и несостыковки.

Как исправить
	•	В одном месте вычислить activeVersionId = candidate?.id ?? current.id и передавать его во все useQuery/useMutation на правой панели.
	•	Ключи кэша React Query должны включать activeVersionId, чтобы кэш автоматически переключался при появлении/принятии кандидата.
	•	Инвалидировать оба набора данных при приёме/отклонении (версии, рекомендации, анализ).

Практика (минимальный патч)

const activeVersion = scriptVersions?.candidate ?? scriptVersions?.current;
const activeVersionId = activeVersion?.id;

const recsQuery = useQuery(
  ["/api/projects", projectId, "scene-recommendations", activeVersionId],
  () => api.get(`/api/projects/${projectId}/versions/${activeVersionId}/recommendations`)
);

И при acceptCandidate / rejectCandidate:

queryClient.invalidateQueries(["/api/projects", projectId, "versions"]);
queryClient.invalidateQueries(["/api/projects", projectId, "script-history"]);
queryClient.invalidateQueries(["/api/projects", projectId, "scene-recommendations"]); // без id → все


⸻

3) Ошибка JSON («Expected ‘,’ or ‘}’…»)

Что происходит

Claude периодически возвращает «почти JSON» (лишние запятые/хвосты). На бэке парсится «как есть» → падаем. От этого:
	•	Срывается анализ кандидата,
	•	Сравнение получает кривые данные,
	•	Пользователь видит красный тост.

Как исправить надёжно (и кратко)
	•	Ввести «устойчивый» парсинг:
	1.	быстрая попытка JSON.parse
	2.	если ошибка → json-repair (или собственный санитайзер)
	3.	повторный JSON.parse
	4.	если снова ошибка → retry с упрощённым промптом (мы уже внедряли backoff — просто применить его к этапу парсинга)
	•	Добавить жёсткую JSON-схему на стороне промпта (структурированный ответ, ключи, числовые диапазоны).
	•	На выход API всегда apiResponse.ok/notFound/badRequest (никакого HTML), и никогда не отдаём сырой текст от LLM — только нормализованный объект.

Практика (скелет функции)

function safeParseLLM(jsonStr: string) {
  try { return JSON.parse(jsonStr) } catch (e1) {
    const repaired = jsonRepair(jsonStr); // библиотека или свой фикс
    try { return JSON.parse(repaired) } catch (e2) {
      throw new Error("LLM_JSON_PARSE_FAILED");
    }
  }
}

И обёртка с retry/backoff на уровне вызова анализа.

⸻

4) Почему «снова делаю анализ» и куда делись изменения

Это следствие кэширования и версионирования:
	•	Вы сохранили v5 (кандидат), сцены обновились в редакторе (ОК).
	•	Анализ ещё не был готов → некоторые компоненты увидели metrics=null и сами инициировали fresh analysis (особенно если где-то стоит «если нет кеша — анализируй»).
	•	Часть панелей смотрит не на activeVersionId (п.2), а на currentVersionId → рассинхрон.

Исправление (сводка)
	•	Везде использовать activeVersion (кандидат приоритетнее текущей).
	•	Никогда авто не запускать анализ «если нет метрик» — только по явному триггеру или по завершению «создать кандидата».
	•	После «Сохранить новую версию» сразу:
	•	setQueryData для versions с новым кандидатом,
	•	invalidate для script-history и scene-recommendations,
	•	не запускать повторный анализ автоматически из других компонентов.

⸻

5) Согласованность метрик (исправленные формулы)

Мы уже зафиксировали правильный маппинг (важно в трёх местах, где формируются metrics):
	•	overallScore ← analysisResult.overallScore
	•	hookScore ← analysisResult.breakdown?.hook?.score ?? 0
	•	structureScore ← analysisResult.structureScore ?? 0
	•	emotionalScore ← analysisResult.emotionalScore ?? 0
	•	ctaScore ← analysisResult.ctaScore ?? 0

И используем один helper для маппинга (чтобы не было разноса по файлу).

⸻

6) Мини-DoD, чтобы убедиться, что ничего не сломали
	1.	Сохранил vN+1 → редактор показывает кандидата, баннер виден, правая панель = данные кандидата.
	2.	«Перейти к озвучке» разрешено сразу (с предупреждением) — нет жёсткой блокировки.
	3.	Анализ кандидата завершился → метрики появились у кандидата, сравнение показывает адекватные дельты.
	4.	«Принять новую версию» → кандидат становится текущей; баннер исчез; кэш очищен; правая панель теперь смотрит на новую текущую.
	5.	Ни одной JSON-ошибки при анализе (даже если Claude «похулиганил»).

⸻

7) Почему «столько строк кода» в routes.ts и что с этим делать

Объективно:
	•	В файле перемешаны контроллеры, бизнес-логика и нормализация AI-ответов — отсюда «простыня».
	•	Много однотипных «временных» решений, на которые наслаивались хотфиксы.

Короткий план оздоровления без рисков:
	•	Вынести маппинг метрик/рекомендаций в lib/analysis-mapper.ts.
	•	Вынести LLM-вызовы и парсинг в lib/ai-client.ts (с retry/safeParse).
	•	Хранить/отдавать версии строго через storage/service слой (routes только «склеивает»).

Это не ломает флоу и резко сокращает точки, где можно ошибиться.

⸻

Итог
	•	Починить «Перейти к озвучке» (не блокировать, предупреждать).
	•	Правую панель перевести на activeVersionId.
	•	Добавить устойчивый парсинг JSON + retry на анализ.
	•	Выключить «авто-анализ при отсутствии метрик» вне основного workflow.
	•	Единый helper для маппинга метрик (уже поправили формулы — использовать везде).

Если хочешь, пришлю готовые дифф-сниппеты под ваши файлы (Stage-3, recommendations panel, routes) — вставишь и поедем дальше.