Ок, давай разложу все “симптомы” по полочкам и сразу скажу, какие куски кода нужны для точного фикса. Ниже — что именно ломается, почему это, скорее всего, происходит, и где это чинить.

⸻

Что сейчас не так и почему

1) «Анализ сценария» запускается только со второго раза

Симптом: тост есть, а результатов нет; со второй попытки появляется.

Типичная причина: действие-«процедура» повешено на useQuery с enabled, а не на useMutation. Из-за гонок состояния (shouldAnalyze, data попадает/не попадает в кэш) запрос не стартует, либо стартует и сразу попадает под “isStale/hasData”.
Как чинить: перевести кнопку анализа на useMutation, а результаты — явно invalidateQueries([...script-history]) + отдельный refetch.

Файлы:
	•	client/src/components/project/stages/stage-3-ai-analysis.tsx (логика кнопки/React Query)
	•	client/src/lib/api.ts (если есть общий враппер под запросы)

⸻

2) В сравнении версий метрики «каша» (новая хуже старой, нули и т.д.)

Симптом: дельта “хука” растёт, другие — нули; иногда «после» хуже «до», хотя тексты лучше.

Причины (часть мы уже ловили):
	•	Формулы: вы уже нашли баг — structureScore/emotionalScore/ctaScore брались из breakdown.*.score, а модель возвращает их на верхнем уровне. Нужно убедиться, что это поправлено во всех местах (создание анализа при сравнении, реанализ кандидата, быстрый анализ сцен).
	•	Неверно сопоставляются версии при сравнении (в модалку прилетает currentVersion слева и не тот candidate справа, либо справа ещё пустой, без metrics).
	•	Модалка открывается до завершения реанализа – и вы видите «скелет» данных как нули. Нужен polling до статуса ready.

Как чинить:
	•	Ещё раз пройтись по всем местах, где собираются метрики из ответа AI (3 участка в server/routes.ts минимум) и убедиться, что берём analysisResult.structureScore, analysisResult.emotionalScore, analysisResult.ctaScore.
	•	В модалке сравнения: сначала создать версию (candidate), запустить её анализ, пока не status=done — не показывать метрики; polling/subscribe → затем грузим metrics.
	•	Сопоставление версий: в payload модалки передавать конкретные versionIdBefore и versionIdAfter (UUID), а не «текущую по состоянию».

Файлы:
	•	server/routes.ts — разделы:
	•	POST анализа сценария;
	•	анализ при создании/сохранении версии;
	•	анализ при сравнении.
	•	client/src/components/project/compare-modal.tsx (или как у вас называется модалка сравнения) — логика ожидания/поллинга, подстановка именно той версии.
	•	server/storage.ts (или сервис версияции) — кто помечает is_candidate/is_current, где лежат metrics.

⸻

3) «Сцены ДО/ПОСЛЕ» ок, а «Метрики» в сравнении — нули

Это почти всегда из пункта 2: либо формулы, либо вы показываете метрики до того, как они реально посчитались для candidate.

⸻

4) После «Сохранить новую версию» на озвучке пусто

Симптом: переход на Stage «Voice», а сценария нет.

Причина: страница озвучки берёт не «активную» версию (кандидата, если пользователь её принял, либо текущую), а что-то другое (например, currentVersion всегда, даже если у нас свежий candidate и вы ещё не нажали «Принять»). Либо у эндпоинта на озвучку нет параметра versionId и он тащит “по умолчанию”.

Как чинить:
	•	Озвучка должна забирать activeVersion. По вашей новой модели:
	•	Если есть accepted/current → берём её;
	•	Если пользователь в модалке нажал «Принять» — только тогда делаем is_current=true в БД;
	•	Если он не принимал, а просто ушёл на озвучку — берите candidate как активную для предпрослушивания (или покажите баннер «Примите версию, чтобы озвучить» — на выбор, но единообразно).
	•	Добавить явную передачу versionId в эндпоинт синтеза/рендера.

Файлы:
	•	client/src/components/project/stages/stage-4-voice-generation.tsx (или где у вас UI озвучки) — источник данных/выбор версии
	•	server/routes.ts — GET/POST для генерации речи/рендера; убедиться, что принимают versionId и не игнорируют.

⸻

5) «Рекомендаций нет до первого клика, потом вдруг появляются»

Это снова про мутацию вместо query + кэш-инвалидацию. После применения рекомендаций:
	•	локально меняем текст сцены;
	•	делаем PATCH /scene (или batch) → по завершении: invalidate ['/api/projects', id, 'script-history'] и ['/api/projects', id, 'scene-recommendations'] с exact:false.
	•	Кнопка «Сохранить новую версию» — активируется по флагу «есть несохранённые изменения» или «были применены рекомендации».

Файлы:
	•	client/src/components/project/scene-editor.tsx (применение одной/всех рекомендаций, инвалидация кэша)
	•	server/routes.ts — PATCH apply recommendation / apply-many.

⸻

Что прислать (точечный набор файлов)

Если пришлёшь вот эти файлы — я смогу сразу указать точные строки/правки:

Backend
	1.	server/routes.ts — целиком или минимум блоки:
	•	/api/projects/:id/analyze-source (Stage 3 анализ исходника)
	•	/api/projects/:id/analysis/run (анализ сценария)
	•	/api/projects/:id/versions (создание версии)
	•	/api/projects/:id/versions/:versionId/accept и /reject
	•	эндпоинты сравнения и получения метрик для версий
	•	эндпоинты озвучки (voice/tts/video render), которые читают сценарий
	2.	server/ai-service-advanced.ts — агенты и место, где формируется финальный результат (важно увидеть, как назваются поля в ответе, чтобы свести с формулами).
	3.	server/storage.ts (или ваш слой DAL/репозиторий) — как хранятся script_versions, metrics, scene_recommendations.
	4.	shared/schema.ts — типы ScriptVersion, Metrics, SceneRecommendation.

Frontend
5. client/src/components/project/stages/stage-3-ai-analysis.tsx — вся логика кнопки анализа, «создать сценарий», загрузка рекомендаций, показ кандидата/текущей версии, баннер.
6. client/src/components/project/scene-editor.tsx — применение рекомендаций, сохранение новой версии, инвалидация кэша.
7. client/src/components/project/compare-modal.tsx — что передаём в модалку, как ждём анализ кандидата, какие versionId сравниваем.
8. client/src/components/project/stages/stage-4-voice-generation.tsx (или где UI озвучки) — откуда берём текст/scripts, какой versionId используем.
9. (Мелочь) client/src/lib/queries.ts (если есть) — ключи React Query.

⸻

Короткий план фикса (без переписывания архитектуры)
	1.	Перевести действия в Stage-3/Stage-«Анализ сценария» на useMutation
	•	Явные onSuccess: invalidateQueries(['…/script-history'], { exact:false }) и refetch().
	•	Удалить зависимость от enabled-флагов, которые вечно гоняются.
	2.	Сравнение версий: строгий polling до готовности метрик кандидата
	•	Создали candidate → показали скелет → поллим /versions/:id/status → только после ready грузим метрики.
	•	Формулы метрик: ещё раз проверить во всех местах.
	3.	Единая концепция «activeVersion»
	•	В редакторе показываем candidate если он есть, иначе current.
	•	В озвучке: либо требуем «Принять» (и берём current), либо явно даём озвучивать candidate (но тогда передаём versionId). Главное — последовательно.
	4.	Кэш
	•	Любое изменение контента сцен или статуса версий → invalidate script-history и scene-recommendations (везде с { exact:false }).
	5.	Защитные проверки
	•	В модалке сравнения если метрик нет → показываем “ещё считаем…”, а не нули.
	•	В Stage-4 если текст пуст → показываем понятный баннер “Примите новую версию” или “Создайте сценарий”.

⸻

Почему «так много строк»
	•	routes.ts раздут, потому что в нём и оркестрация, и бизнес-логика, и сериализация, и иногда даже форматирование ответов.
	•	Вынеси:
	•	Агентов/промпты в ai-service-advanced.ts;
	•	Версионирование в script-version-service.ts;
	•	Сравнение в compare-service.ts;
	•	TTS/рендер в voice-service.ts / render-service.ts;
	•	А в routes.ts оставь тонкие endpoints (валидация + вызов сервиса).
Так и баги искать проще, и формулы в одном месте.

⸻

Если пришлёшь файлы по списку выше — я точечно отмечу строки и дам diff-патчи (что вставить/куда). Сейчас по симптомам на 90% уверен, что главные «боли» — это (а) мутации/кэш и (б) цепочка «создать candidate → дождаться метрик → сравнить».